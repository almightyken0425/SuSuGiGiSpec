---
name: tutorial_writing
description: Comprehensive documentation guidelines for Technical Knowledge and Tutorials, focusing on cognitive architecture and mental model construction.
---

# 技術知識文件撰寫政策

## 撰寫哲學

### 基礎原則
- **由下而上建構:** 從協議基礎開始，逐層向上堆疊至應用層，確保知識有堅實的地基。
- **遊戲規則比喻:** 用遊戲設計的概念框架技術系統，讓抽象概念具象化。
- **清晰層次分離:** 區分協議定義與軟體實作，避免概念混淆。
- **完整生命週期:** 涵蓋從靜態結構到動態運作的完整流程。

### 深層方法論
- **資料溯源追蹤:** 每個欄位、每個數值都追溯到源頭，說明 從哪裡來、經過什麼運算、填到哪裡去
  - **層層拆解範例:** 類似物理學介紹功率時不只說 牛頓每秒 ，還要拆解成 (m×a)每秒 等於 (kg×m每s²)每秒 等於 kg×m每s³
  - **比特幣範例:** ScriptPubKey 欄位的完整溯源鏈
    ```
    UI 輸入: 使用者輸入地址 "1A1zP1..."
      ↓ Base58Check 解碼
    公鑰雜湊: 20-byte 的 Pub Key Hash
      ↓ 加上協議定義的 OpCodes
    ScriptPubKey: OP_DUP + OP_HASH160 + <PubKeyHash> + OP_EQUALVERIFY + OP_CHECKSIG
      ↓ 序列化
    二進位: 0x76a914<hash>88ac
      ↓ 填入資料結構
    目標欄位: tx_object['body']['outputs'][0]['script_pub_key']
    ```
  - **目的:** 讓讀者完全理解每一層轉換的依據與邏輯，避免 魔法黑箱
- **多視角敘事:** 同一個機制從協議視角、節點視角、使用者視角、攻擊者視角多維度描述
- **時間維度區分:** 明確標示編譯時、部署時、運行時的不同階段
- **對比式學習:** 透過對比來強化理解，如硬分叉 vs 軟分叉、全節點 vs 輕節點
- **邊界清晰化:** 明確標示什麼是必須的、可選的、禁止的、推薦的
- **演化式思維:** 不只講 是什麼 ，還要講 為何這樣設計 、 演化過程 、 歷史案例
- **錯誤預防:** 提前說明常見誤解與錯誤理解，避免讀者走冤枉路

---

## 認知架構建構 Cognitive Architecture Construction

技術文件的最終目標不是傳遞資訊，而是**在讀者腦中建立可操作的心智模型**。以下是多層次的認知建構方法論：

### 第一層：心智模型地基 Mental Model Foundation

#### 概念錦點 Concept Anchoring
- **定義:** 提供穩固的認知錐點，讓讀者有明確的概念參照點
- **技巧:**
  - **角色定位:** 每個文件開頭都有 角色定義 章節
    - 範例：共識機制是區塊鏈網路的自動仲裁者
    - 目的：先在讀者腦中建立 這是什麼角色 的核心印象
  - **本質描述:** 用一句話解釋本質
    - 範例：交易本質上是一次向去中心化資料庫發送的狀態變更 API 請求
    - 目的：將陌生概念鏤定到熟悉概念
  - **譬喻鏤點:** 提供視覺化的比喻作為記憶掛鉤
    - 範例：UTXO 等於 金幣、Mempool 等於 候機室、節點 等於 守門員
    - 目的：將抽象概念射到具體的視覺心像

#### 結構拆解 Structure Deconstruction
- **定義:** 將複雜資料結構拆解成包含關係，幫助讀者建立階層式心智模型
- **技巧:**
  - **包含關係明確化:**
    - 範例：Block 包含 Transactions、Transactions 包含 Outputs、Outputs 即為 UTXOs
    - 目的：讓讀者知道 UTXO 藏在哪裡，建立層次心智地圖
  - **從整體到部分:**
    - 範例：先介紹 Block Header 加 Block Body，再展開 Header 的 6 個欄位
    - 目的：適合大腦的 Top-Down 處理模式

---

### 第二層：認知負載管理 Cognitive Load Management

#### 漸進式複雜度 Progressive Complexity
- **定義:** 控制資訊披露的節奏，避免認知超載
- **技巧:**
  - **先 是什麼 再 為什麼:**
    - 範例：先說 Coinbase 成熟期 100 區塊，再解釋目的是降低孤兒塊風險
    - 目的：讓讀者先建立事實認知，再加深理解
  - **分階段揭露:**
    - 範例：交易建立文件分為 Payload 定義 接 欄位溯源 接 API 參數生成
    - 目的：每次只讓讀者處理一個層次的資訊
  - **延遲細節:**
    - 範例：先介紹 Target 是難度目標，在 名詞解釋 章節才詳細說明調整機制
    - 目的：主流程保持簡潔，細節可選擇性閱讀

#### 分塊與組塊 Chunking and Grouping
- **定義:** 將資訊分組，利用大腦短期記憶 7加減2 個單位的限制
- **技巧:**
  - **五層金字塔:** 將所有文件分為 5 個大類，每類又細分
    - 目的：讀者只需記住 5 個大框架，避免記憶超載
  - **章節分隔線:** 用 `---` 強制分隔主要上下文
    - 目的：視覺上的分塊，減少閱讀疲勞
  - **標題階層:** ## 主要概念 接 ### 子概念 接 #### 細節
    - 目的：建立清晰的階層心智樹

---

### 第三層：概念連結網路 Concept Connection Network

#### 多向連結 Multi-Directional Linking
- **定義:** 建立概念之間的多重連結，形成知識網路
- **技巧:**
  - **因果連結:**
    - 範例：因為 PrevBlockHash 指向前一個區塊，所以任何歷史修改都會導致後續所有區塊 Hash 改變
    - 目的：建立機制之間的因果連結
  - **跨層引用:**
    - 範例：在交易建立文件中引用 依據創世協議規範
    - 目的：讓讀者知道這個概念從哪個基礎層來
  - **對比連結:**
    - 範例：硬分叉 vs 軟分叉的對比表
    - 目的：透過對比強化記憶，建立分類心智模型

#### 概念重複強化 Concept Reinforcement
- **定義:** 在不同視角、不同層次重複關鍵概念，加深印象
- **技巧:**
  - **多視角重述:**
    - 範例：TxID 在交易建立文件中介紹生成，在節點文件中介紹索引
    - 目的：讓讀者從不同角度理解同一個概念
  - **編譯時 vs 運行時:**
    - 範例：創世區塊 Hash 是編譯時，當前 Target 是運行時
    - 目的：將時間維度也約入心智模型

---

### 第四層：理解驗證與回饋 Understanding Verification and Feedback

#### 立即驗證 Immediate Verification
- **定義:** 提供立即回饋機制，讓讀者確認自己真的懂了
- **技巧:**
  - **Demo Code 模擬:**
    - 範例：提供可執行的 Python 代碼模擬整個流程
    - 目的：讀者可以自己運行確認結果
  - **視覺化範例:**
    - 範例：提供 JSON 格式的完整區塊結構範例
    - 目的：讀者可以對照自己的理解
  - **事實 + 範例 + 結論:**
    - 範例：你有 10oz 金幣 接 支付 3oz 接 鑄造 3oz及7oz
    - 目的：三段式說明讓讀者自我驗證理解

#### 錯誤預防與澄清 Error Prevention and Clarification
- **定義:** 提前說明常見誤解，避免讀者建立錯誤的心智模型
- **技巧:**
  - **明確澄清:**
    - 範例：UTXO 並非直接寫在區塊上的欄位，而是藏在 Transaction List
    - 目的：打破初學者可能的錯誤直覺
  - **微妙區分:**
    - 範例：TxID 對 包含簽章 的交易雜湊，但簽章本身對 不含簽章 的摘要簽名
    - 目的：說明容易混淆的技術細節
  - **關鍵警示:**
    - 範例：礦工無決定權，礦工只負責廣播，獎勵歸屬由網路共識決定
    - 目的：糰正可能的錯誤假設

---

### 第五層：記憶提取優化 Memory Retrieval Optimization

#### 多重編碼 Multi-Encoding
- **定義:** 同一個概念以多種形式編碼，提供多個提取路徑
- **技巧:**
  - **文字 + 代碼 + 視覺:**
    - 範例：Merkle Root 用文字描述 加 Python 代碼 加 ASCII 樹狀圖
    - 目的：視覺型與語言型學習者都能理解
  - **抽象 + 具體:**
    - 範例：工作量證明 加 像擲 2的256次方 面的骰子
    - 目的：抽象概念用具體比喻強化
  - **中文 + 英文:**
    - 範例：異狀文件輸出 Unspent Transaction Output
    - 目的：提供雙語言索引路徑

#### 結構化回顧 Structured Review
- **定義:** 提供清晰的總結與對比表，方便快速回顧
- **技巧:**
  - **對比表格:**
    - 範例：全節點 vs 輕節點 vs SPV 節點的對比表
    - 目的：一眼掌握關鍵差異，快速提取
  - **結論章節:**
    - 範例：每個大章節後的 結論 段落
    - 目的：強化核心訊息的記憶固化
  - **層級編號:**
    - 範例：`no1_1` 代表 第一層第一個文件
    - 目的：提供空間定位記憶索引

#### 連接與回錄 Links and Callbacks
- **定義:** 建立文件間的連接，但不使用硬編碼檔名
- **技巧:**
  - **主題引用:**
    - 範例：依據創世協議規範 而非 依據 no1_1_genesis_protocol_code.md
    - 目的：讀者透過主題連結概念，而非檔案
  - **層級暱示:**
    - 範例：交易建立文件中引用 協議層 的概念
    - 目的：提醒讀者概念的層級位置

---

### 第六層：心智模型驗證 Mental Model Validation

#### 多場景測試 Multi-Scenario Testing
- **定義:** 提供多個場景讓讀者測試自己的理解
- **技巧:**
  - **正常流程 + 邊緣案例:**
    - 範例：交易建立的正常流程 加 雙重花費情境
    - 目的：確保讀者理解機制的邊界
  - **成功案例 + 失敗案例:**
    - 範例：成功 Hash 小於 Target 為成功，失敗 Hash 大於 Target 為失敗
    - 目的：透過對比加深印象
  - **IF 條件分支:**
    - 範例：**IF** 區塊 A 成為孤兒塊 則 獎勵消失
    - 目的：讓讀者模擬不同場景的結果

#### 效果驗證 Effect Verification
- **定義:** 明確說明「這樣做會導致什麼」
- **技巧:**
  - **因果鏈:**
    - 範例：修改歷史區塊 導致 Hash 改變 導致 後續區塊全部無效
    - 目的：讓讀者理解連鎖效應
  - **經濟後果:**
    - 範例：硬分叉 導致 永久分裂 導致 生態擕裂 導致 市值波動
    - 目的：建立完整的後果心智模型

## High-Level 撰寫脈絡框架

技術知識文件應依循五層金字塔結構，從底層基礎逐步建構至頂層應用：

### 第一層：遊戲說明書 Game Rulebook
- **目標:** 定義系統的核心協議規範與不可變規則
- **內容範疇:**
  - 協議層面的核心定義與結構規範
  - 區分系統內名詞與系統外技術依賴
  - 經濟模型、共識規則、通訊規則等基礎設定
- **檔案編號建議:** `no1_X`
- **關鍵特徵:**
  - 這些規則在系統啟動前就已寫死
  - 作為所有後續機制的數位憲法
  - 需明確標示哪些是協議定義，哪些是外部技術如 SHA256、ECDSA

### 第二層：關鍵角色 Key Players
- **目標:** 介紹遊戲規則本身定義的抽象職責與資料結構
- **內容範疇:**
  - 身份系統與密碼學基礎
  - 資料結構定義，如帳本結構、狀態模型
  - 角色的抽象職責與權利義務
- **檔案編號建議:** `no2_X`
- **關鍵特徵:**
  - 這些角色會貫穿整個系統文件
  - 僅描述抽象定義，不涉及具體實作
  - 需提供視覺化譬喻幫助理解，如金幣模型

### 第三層：軟體實作角色 Software Implementation Roles
- **目標:** 介紹非遊戲規則定義但實際運作時必須的軟體角色
- **內容範疇:**
  - 節點、錢包、礦工等軟體類型
  - 區分協議定義 vs 軟體實作 vs 硬體載體三層架構
  - 各軟體角色的 Method 與職責分工
- **檔案編號建議:** `no3_X`
- **關鍵特徵:**
  - 明確標示這些是實作選擇，非協議強制
  - 說明同一協議可有多種客戶端實作
  - 列舉實際軟體範例，如 Bitcoin Core、Metamask

### 第三層：遊戲實際啟動 Game Runtime
- **目標:** 描述系統從啟動到持續運作的完整流程
- **內容範疇:**
  - 交易生命週期：建立、簽署、廣播、驗證
  - 共識達成流程：挖礦、區塊傳播、鏈重組
  - 資料流轉與狀態轉換
- **檔案編號建議:** `no4_X`
- **關鍵特徵:**
  - 從靜態結構轉向動態流程
  - 需提供完整的 Demo Code 或邏輯演示
  - 涵蓋正常流程與邊緣情況

### 第五層：遊戲價值與演化 Core Value & Evolution
- **目標:** 闡述系統的核心價值與規則修改機制
- **內容範疇:**
  - 共識機制的價值：去中心化、抗審查、經濟安全
  - 分叉類型與後果：硬分叉 vs 軟分叉
  - 治理機制：鏈上 vs 鏈外決策
- **檔案編號建議:** `no5_X`
- **關鍵特徵:**
  - 說明為何這個系統有價值
  - 描述修改規則的代價與風險
  - 提供實際案例如 Bitcoin Cash、SegWit

---

## 文件命名規範 (技術文件篇)

### 技術知識文件格式
- **格式:** `no層級_序號_主題.md`
- **層級:**
  - `1`: 協議規範 Protocol
  - `2`: 資料結構與角色 Data Structure & Roles
  - `3`: 軟體實作 Software Implementation
  - `4`: 運作流程 Runtime Flow
  - `5`: 共識與治理 Consensus & Governance
- **序號:**
  - 同層級內的排序編號
  - 建議用 `1`, `2`, `3` 而非 `01`, `02`
- **主題:**
  - 全小寫英文
  - 使用 `_` snake_case 分隔
  - 可包含雙語標示如 `identity_and_address`

### 範例
- `no1_1_genesis_protocol_code.md`
- `no2_1_identity_and_address.md`
- `no3_1_node_and_wallet.md`
- `no4_1_transaction_creation.md`
- `no5_2_fork_types.md`

---

## 核心撰寫原則

### 名詞定義與分類
- **系統內名詞 Protocol Terms:**
  - 由協議本身定義的概念
  - 範例：Block Header, Merkle Root, Coinbase Transaction, UTXO, Nonce
  - **處理方式:** 首次出現時提供定義與中英對照
- **系統外技術 External Technologies:**
  - 協議依賴但非自身定義的技術
  - 範例：SHA256, ECDSA, P2P Network, Keccak256
  - **處理方式:** 簡述用途即可，必要時提供外部連結

### 層次清晰分離
- **協議層 Protocol Layer:**
  - 描述 規則是什麼
  - 範例：創世協議規定 Public Key Hash 必須經過 SHA256 加 RIPEMD160
- **應用層 Application Layer:**
  - 描述 軟體如何實作
  - 範例：錢包軟體使用 Base58Check 編碼地址以提升可讀性
- **硬體層 Hardware Layer:**
  - 描述 實際運行載體
  - 範例：ASIC 礦機專門執行 SHA256 雜湊運算

### 資料溯源追蹤 Data Provenance Tracking
- **關鍵欄位溯源表格結構:**
  - **來源 Source:** 這個數值從哪裡來？UI 輸入、資料庫查詢、計算結果
  - **原始資料 Raw Data:** 未經處理的原始格式
  - **處理程序 Process:** 經過了哪些演算法或轉換
  - **目的與位置 Target:** 最終填入資料結構的哪個欄位
- **範例:** 參見 `no4_1_transaction_creation.md` 的 關鍵欄位溯源與生成 章節

### 多視角敘事 Multi-Perspective Narration
- **協議視角 Protocol View:**
  - 描述規則本身如何定義，不涉及實作細節
  - 範例：協議規定 Public Key Hash 必須經過 SHA256 加 RIPEMD160
- **節點視角 Node View:**
  - 描述節點如何執行驗證與處理邏輯
  - 範例：節點收到新區塊後的 SOP 有 驗證 PoW、驗證交易、更新帳本
- **使用者視角 User View:**
  - 描述錢包或客戶端如何與系統互動
  - 範例：使用者在錢包介面的接收地址欄位輸入 `1A1z...`
- **攻擊者視角 Attacker View:**
  - 說明攻擊成本與經濟不可行性
  - 範例：攻擊者需要控制超過 50% 算力並秘密挖 7 個區塊

### 時間維度區分 Temporal Dimension
- **編譯時 Compile Time:** 協議寫死的常數與規則
  - 範例：創世區塊 Hash、總供應量 2100 萬、減半週期
- **部署時 Deploy Time:** 網路啟動或升級時確定的參數
  - 範例：種子節點 IP、魔法數字、初始難度
- **運行時 Runtime:** 動態調整或計算的數值
  - 範例：當前難度 Target、Mempool 狀態、UTXO Set

### 邏輯演示 Demo Code
- **目的:** 將抽象規則具象化為可執行的邏輯
- **格式要求:**
  - 使用 Python 或 JavaScript 等高階語言
  - 僅示意邏輯流程，非生產級代碼
  - 添加註解說明每個步驟的協議依據
  - **註解分類:** 使用 `# 指令` `# 資料` `# 步驟` 等前綴區分不同類型的註解
- **範例:**
  ```python
  # 1. 協議層: 雙重雜湊生成 Public Key Hash
  sha256_hash = SHA256(public_key)
  pub_key_hash = RIPEMD160(sha256_hash)
  
  # 2. 應用層: 計算校驗碼並編碼為 Address
  checksum = SHA256(SHA256(pub_key_hash)).first_4_bytes()
  address = Base58Encode(pub_key_hash + checksum)
  ```

### 對比式學習 Contrast-Based Learning
- **結構化對比表:**
  - 使用 Markdown 表格呈現關鍵差異
  - 範例：硬分叉 vs 軟分叉、全節點 vs 輕節點 vs SPV 節點
- **關鍵差異提取:**
  - 不只列出不同，還要說明 為何不同 、 影響是什麼
- **選擇考量:**
  - 提供決策指引，說明何時應該選擇哪種方案

### 邊界清晰化 Boundary Clarification
- **必須 Must:** 協議強制要求，違反會被拒絕
  - 範例：Block Hash 必須小於 Target
- **推薦 Should:** 最佳實踐，不遵守可能有副作用
  - 範例：建議等待 6 個確認後才認定交易不可逆
- **可選 May:** 實作選擇，可自由決定
  - 範例：礦工可依利潤最大化策略選擇交易
- **禁止 Must Not:** 明確禁止的行為
  - 範例：Coinbase 獎勵在 100 個區塊前不可花費

### 演化式思維 Evolutionary Thinking
- **設計動機 Design Rationale:**
  - 說明 為何要這樣設計 而非只講 是什麼
  - 範例：Coinbase 成熟期 100 區塊的目的是降低孤兒塊風險
- **歷史案例 Historical Cases:**
  - 引用真實事件或分叉案例
  - 範例：Bitcoin Cash、SegWit、The DAO 事件
- **演化路徑 Evolution Path:**
  - 說明技術如何從初版演化至今
  - 範例：從 P2PKH 到 P2SH 到 SegWit 的地址格式演化

### 錯誤預防 Error Prevention
- **常見誤解澄清:**
  - 提前說明初學者容易混淆的概念
  - 範例：UTXO 並非直接寫在區塊上的欄位，而是藏在 Transaction List 裡面的 Output 資訊
- **技術陷阱警示:**
  - 標示容易出錯的技術細節
  - 範例：TxID 是對 包含簽章 的完整交易進行雙重雜湊，而簽章本身是對 不含簽章 的交易摘要進行簽名
- **語境敏感詞彙:**
  - 說明同一個詞在不同語境下的不同含義
  - 範例：Target 在挖礦語境指難度目標數值，在交易語境指目標地址

### 譬喻與視覺化
- **金幣譬喻:** UTXO 模型如同鎔鑄金幣
- **候機室譬喻:** Mempool 如同交易候機室
- **守門員譬喻:** 節點如同網路的守門員
- **遊戲規則譬喻:** 協議如同遊戲說明書
- **前後端譬喻:** 錢包是前端、節點是後端、礦工是生產端

---

## 章節結構規範 (技術文件篇)

### 協議規範文件 Protocol Specification
推薦章節順序：
- `## 規範目標` 說明此協議文件的目的
- `## 核心定義` 定義關鍵術語與概念
- `## 結構規範` 描述資料結構與欄位定義
- `## 規則設定` 說明共識規則、經濟模型等
- `## 邏輯演示` 提供 Demo Code 或運算範例

### 流程文件 Process Documentation
推薦章節順序：
- `## 角色定義` 說明此流程涉及的參與者
- `## 流程步驟` 依時間順序描述完整流程
- `## 資料結構` 說明流程中的資料格式
- `## 關鍵欄位溯源` 追溯每個欄位的來源與生成方式
- `## 邊緣情況` 描述異常情境與錯誤處理

### 機制文件 Mechanism Documentation
推薦章節順序：
- `## 機制定位` 說明此機制在系統中的角色
- `## 核心特徵` 列出關鍵特性與設計目標
- `## 運作邏輯` 描述機制如何工作
- `## 實際案例` 提供歷史事件或實例
- `## 對比分析` 與其他機制或方案比較

---

## 絕對禁止項目 (繼承 Spec 篇+額外增補)

- **絕對禁止技術黑箱:**
  - **嚴禁** 使用 底層實現 、 內部處理 等模糊描述
  - **要求:** 必須具體說明演算法或邏輯流程
- **絕對禁止循環定義:**
  - **嚴禁** A 定義引用 B，B 定義又引用 A
  - **要求:** 確保依賴關係為有向無環圖 DAG
- **絕對禁止概念混淆:**
  - **嚴禁** 將協議定義與軟體實作混為一談
  - **要求:** 明確標示每段描述屬於協議層或應用層
- **絕對禁止跳躍式講解:**
  - **嚴禁** 在未定義基礎概念前就使用進階術語
  - **要求:** 嚴格遵守五層金字塔的由下而上順序
- **絕對禁止資料黑洞:**
  - **嚴禁** 出現 這個值從某處來 但不說明具體來源
  - **要求:** 每個欄位都必須追溯到最終源頭
- **絕對禁止單一視角:**
  - **嚴禁** 只從一個角度描述機制
  - **要求:** 關鍵機制需提供多視角描述
